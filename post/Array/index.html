<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lainbo</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://lainbo.github.io//favicon.ico?v=1577677756357">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://lainbo.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Lainbo - Atom Feed" href="https://lainbo.github.io//atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://lainbo.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://lainbo.github.io//images/avatar.png?v=1577677756357" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Lainbo</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">数组的构造器</a></li>
<li><a href="#es6%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95">ES6新增的构造函数方法</a>
<ul>
<li><a href="#arrayof-chrome-45%E6%94%AF%E6%8C%81">Array.of() | Chrome 45+支持</a></li>
<li><a href="#arrayfrom">Array.from</a></li>
<li><a href="#arrayisarray-ie-9%E6%94%AF%E6%8C%81">Array.isArray() | IE 9+支持</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95">数组方法</a><br>
*
<ul>
<li><a href="#1arraypush%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">1）Array.push()（末尾添加元素）</a></li>
<li><a href="#2arraypop%E5%88%A0%E9%99%A4%E6%9C%80%E5%90%8E%E4%B8%80%E9%A1%B9">2）Array.pop()（删除最后一项）</a></li>
<li><a href="#3-arrayunshift%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E9%A1%B9">3) Array.unshift()（开始位置添加一项）</a></li>
<li><a href="#4-arrayshift%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%E4%B8%80%E9%A1%B9">4) Array.shift()（开始位置删除一项）</a></li>
<li><a href="#5-arraysplice%E5%88%A0%E9%99%A4-%E6%B7%BB%E5%8A%A0-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0">5） Array.splice()（删除、添加、修改元素）</a></li>
<li><a href="#6-arrayindexof%E4%BB%8E%E5%B7%A6%E5%90%91%E5%8F%B3%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%85%BC%E5%AE%B9ie%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8ie678">6） Array.indexOf()（从左向右查询）不兼容IE低版本浏览器：IE6,7,8</a></li>
<li><a href="#7-arraylastindexof%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%85%BC%E5%AE%B9ie%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8ie678">7） Array.lastIndexOf()（从左到右查询）不兼容IE低版本浏览器：IE6,7,8</a></li>
<li><a href="#8-arrayslice%E6%88%AA%E5%8F%96">8） Array.slice()（截取）</a></li>
<li><a href="#9-arraysort%E6%8E%92%E5%BA%8F">9) Array.sort()（排序）</a></li>
<li><a href="#10-arrayreverse%E5%80%92%E5%BA%8F">10) Array.reverse()（倒序）</a></li>
<li><a href="#11-arrayconcat%E6%8B%BC%E6%8E%A5%E6%95%B0%E7%BB%84">11) Array.concat()（拼接数组）</a></li>
<li><a href="#12-arrayjoin%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">12) Array.join()（数组拼接成字符串）</a></li>
<li><a href="#13-arrayflat%E6%8B%89%E5%B9%B3%E6%95%B0%E7%BB%84">13) Array.flat()(拉平数组)</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95">数组的遍历方法</a>
<ul>
<li><a href="#1-arraymap%E6%98%A0%E5%B0%84">1) Array.map()（映射）</a></li>
<li><a href="#2-arrayforeach%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">2） Array.forEach()（遍历数组）</a></li>
<li><a href="#3-arrayfindfindindex%E6%9F%A5%E6%89%BE">3) Array.find&amp;findIndex(查找)</a></li>
<li><a href="#4-arrayfilter%E8%BF%87%E6%BB%A4">4) Array.filter(过滤)</a></li>
<li><a href="#5-arrayevery%E6%B5%8B%E8%AF%95%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0">5) Array.every(测试所有元素)</a></li>
<li><a href="#6-arrayincludes%E5%8C%85%E5%90%AB">6) Array.includes()(包含)</a></li>
<li><a href="#7-arrayreduce%E7%B4%AF%E5%8A%A0%E5%99%A8">7） Array.reduce(累加器)</a></li>
<li><a href="#8-arraysome">8) Array.some()</a></li>
<li><a href="#9-arraykeys">9) Array.keys()</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://lainbo.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">数组相关的杂七杂八</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-04-03 / 17 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://s2.ax1x.com/2019/12/30/lM8BL9.jpg" alt="">
        
        <div class="post-content yue">
          <h2 id="数组的构造器">数组的构造器</h2>
<p>数组的构造器其实要比一般写的更简单点，除了字面量的声明方法，其实还可以使用Array()，你可能会说：我觉的字面量的方法也很方便呀，那么来看看下面的代码</p>
<pre><code class="language-JavaScript">var a = Array(8); // [undefined × 8]
// 使用对象字面量
var b = [];
b.length = 8; // [undefined × 8]
</code></pre>
<p>在这里看来使用Array的方法要让代码更加有辨识度，其实也各有各的好处，如果在声明的时候直接赋值那可能还是字面量的形式更加容易书写和辨认。</p>
<hr>
<p>可能你注意到了这一点，我并没有写new Array(8)，而是写了Array(8)，实际上这并没有影响，这得益于Array构造函数内部对this的判断，在ECMA的规范中大概说了一个</p>
<blockquote>
<p>When Array is called as a function rather than as a constructor, it creates and initialises a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.</p>
</blockquote>
<p>大概意思是说，如果你直接用了Array()，而没有用new Array()，他也将创建一个新的Array对象，等效于new Array()</p>
<hr>
<h2 id="es6新增的构造函数方法">ES6新增的构造函数方法</h2>
<h3 id="arrayof-chrome-45支持">Array.of() | Chrome 45+支持</h3>
<p>Array.of()用于将参数依次转化为数组中的一项，不管这个参数是数字还是其他，基本上和Array一致，只不过对单个参数的情况做了处理</p>
<pre><code class="language-JavaScript">var a = Array.of(8)
console.log(a) //[8],而不是长度为8的数组
</code></pre>
<h3 id="arrayfrom">Array.from</h3>
<p>Array.from()可以快速的从一个类似数组的可迭代对象创建一个新的数组实例，说人话就是只要这个对象可以循环，就能用，甚至是一个字符串都可以，Array.from()可以把他变成一个数组(生成新的数组，不改变原来的对象)</p>
<blockquote>
<p>语法：Array.from(arrayLike[, processingFn[, thisArg]])</p>
</blockquote>
<p>Array.from()有3个形参，第1个为类似数组的对象，第2个为加工函数，新生成的对象会经过这个函数的加工再返回，这个函数必须要return，不然会返回undefined，第3个参数为this的作用域，表示加工函数执行时this的值，后两个参数可选</p>
<pre><code class="language-JavaScript">var obj = {
  0: '第一条',
  1: '第二条',
  2: '第三条',
  length: 3
}
var temp = Array.from(obj)
console.log(temp) //[ '第一条', 第二条, '第三条' ]
</code></pre>
<p>值得注意的是，属性名必须是数字或者可以转换成数值的，比如例子中的0,1,2，且必须有length属性，实际上，如果不需要指定this，加工函数完全可以是一个箭头函数，除了上述obj对象以外，拥有迭代器的对象还包括这些：String，Set，Map，arguments</p>
<h3 id="arrayisarray-ie-9支持">Array.isArray() | IE 9+支持</h3>
<p>顾名思义，这个是用来判断是不是数组的，他比instanceof更加准确一些，先来看看ES5中怎么判断一个值是否为数组</p>
<pre><code class="language-javaScript">var a = [];

// 1.基于instanceof
a instanceof Array;

// 2.基于constructor
a.constructor === Array;

// 3.基于Object.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(a);

// 4.基于getPrototypeOf
Object.getPrototypeOf(a) === Array.prototype;

// 5.基于Object.prototype.toString
Object.prototype.toString.apply(a) === '[object Array]';
</code></pre>
<p>以上方法中，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型，其他方法只要我们手动指定了__proto__为Array，这些基于继承判断数组的方法就失去了意义</p>
<ul>
<li>Array.isArray()用法</li>
</ul>
<pre><code class="language-JavaScript">Array.isArray([]); // true
Array.isArray({0: 'a', length: 1}); // false
</code></pre>
<p>实际上，通过Object.prototype.toString去判断一个值的类型，也是各大主流库的标准,只要别轻易去动这个toString()就行</p>
<hr>
<h1 id="数组方法">数组方法</h1>
<h3 id="1arraypush末尾添加元素">1）Array.push()（末尾添加元素）</h3>
<ul>
<li>作用：向数组的末尾添加n个元素</li>
<li>参数：参数时新增的元素，可以串多个</li>
<li>返回值：新数组的数组成员的个数</li>
<li>原数组发生变化</li>
<li>实际上，push方法是根据length属性来决定从哪里开始插入给定的值。</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5];
	console.log(arr.push(5));   // 6
  console.log(arr); // [1,2,3,4,5,5]
</code></pre>
<ul>
<li>利用push根据length属性插入元素这个特点，可以实现数组的合并，如下：</li>
</ul>
<pre><code class="language-JavaScript">var array = [&quot;football&quot;, &quot;basketball&quot;];
var array2 = [&quot;volleyball&quot;, &quot;golfball&quot;];
var i = Array.prototype.push.apply(array,array2);
console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;golfball&quot;]
console.log(i); // 4
</code></pre>
<p>其实好像还是concat()性能更好点</p>
<h3 id="2arraypop删除最后一项">2）Array.pop()（删除最后一项）</h3>
<ul>
<li>作用：删除数组的最后一项</li>
<li>参数：不需要传参数</li>
<li>返回值：被删除的那一项</li>
<li>原数组发生改变</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5];
	console.log(arr.pop());// 5
  console.log(arr);  //[1,2,3,4]
</code></pre>
<h3 id="3-arrayunshift开始位置添加一项">3) Array.unshift()（开始位置添加一项）</h3>
<ul>
<li>作用：向数组的开始位置添加n个元素</li>
<li>参数：参数是新增的元素，可以是多个</li>
<li>返回值：新数组的长度</li>
<li>原数组发生改变</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5]
	console.log(arr.unshift(2))    // 6
  console.log(arr)  //[2,1,2,3,4,5]
</code></pre>
<h3 id="4-arrayshift开始位置删除一项">4) Array.shift()（开始位置删除一项）</h3>
<ul>
<li>作用：删除数组的第一项</li>
<li>参数：不需要传参数</li>
<li>返回值：被删除的那一项</li>
<li>原数组发生改变</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5]
	console.log(arr.shift())  // 1
  console.log(arr)   // [2,3,4,5]
</code></pre>
<h3 id="5-arraysplice删除-添加-修改元素">5） Array.splice()（删除、添加、修改元素）</h3>
<ul>
<li>作用：删除元素，并向数组添加新元素</li>
<li>参数：
<ul>
<li>splice(m,n);从索引m开始，删除n项</li>
<li>splice(m);从索引m开始删除到末尾</li>
<li>splice(m,n,x,...);从索引m开始删除n项，并将x添加到原来位置；添加项可以是多个（如果删除项为0个，那么添加是在m元素前面）</li>
</ul>
</li>
<li>返回值：是个数组，数组中是被删除的项</li>
<li>原数组发生变化</li>
</ul>
<h3 id="6-arrayindexof从左向右查询不兼容ie低版本浏览器ie678">6） Array.indexOf()（从左向右查询）不兼容IE低版本浏览器：IE6,7,8</h3>
<ul>
<li>作用：检测数组中是否存在某个元素</li>
<li>参数：被查询的元素（m,n）从索引n开始，m第一次出现的索引位置</li>
<li>返回值：
<ul>
<li>返回数组中第一次匹配到的元素的索引</li>
<li>如果数组中没有匹配项返回-1</li>
</ul>
</li>
<li>indexOf使用严格相等（即使用 === 去匹配数组中的元素）。</li>
<li>原数组不发生变化</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5,2]
	let arr1 = arr.indexOf(2)
	console.log(arr1)  // 1
	let arr2 = arr.indexOf(9)
	console.log(arr2)  // -1
</code></pre>
<h3 id="7-arraylastindexof从左到右查询不兼容ie低版本浏览器ie678">7） Array.lastIndexOf()（从左到右查询）不兼容IE低版本浏览器：IE6,7,8</h3>
<ul>
<li>作用：检测数组中是否存在某个元素</li>
<li>参数：被检测的元素</li>
<li>返回值：
<ul>
<li>返回数组中最后一次匹配到的元素的索引</li>
<li>如果数组中没有匹配项返回-1</li>
</ul>
</li>
<li>lastIndexOf使用严格相等（即使用 === 去匹配数组中的元素）。</li>
<li>原数组不发生变化</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5,2]
	let arr1 = arr.lastIndexOf(2)
	console.log(arr1)  // 5
	let arr2 = arr.lastIndexOf(9)
	console.log(arr2)  // -1
</code></pre>
<h3 id="8-arrayslice截取">8） Array.slice()（截取）</h3>
<ul>
<li>作用：按照起始和结束位置的索引截取数组</li>
<li>参数：
<ul>
<li>有两个参数slice(m,n)：从索引m开始，截取到索引n；（包前不包后）</li>
<li>有一个参数slice(m)：从索引m开始截取到末尾；<br>
没有参数：数组的克隆；(slice(0)也是数组的克隆)；<br>
以上情况参数都支持负数，负数情况会默认被加上数组的长度，处理成正数</li>
</ul>
</li>
<li>返回值：截取的数组</li>
<li>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。</li>
<li>原数组不发生变化</li>
<li>同时，稍微利用下 slice 方法第一个参数为负数时的特性，我们可以非常方便的拿到数组的最后一项元素</li>
</ul>
<pre><code class="language-JavaScript">console.log([1,2,3].slice(-1));//[3]
</code></pre>
<ul>
<li>用法</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5]
	console.log(arr.slice(1,3))   // [2,3]
  console.log(arr)    //  [1,2,3,4,5]
</code></pre>
<h3 id="9-arraysort排序">9) Array.sort()（排序）</h3>
<ul>
<li>
<p>作用：对数组的元素进行排序</p>
</li>
<li>
<p>参数：</p>
<ul>
<li>没有参数sort()：只能排序数组成员项是相同位数的数字</li>
<li>sort(function(a,b){return a-b})：从小到大排序</li>
<li>sort(function(a,b){return b-a})：从大到小排序</li>
</ul>
</li>
<li>
<p>返回值：排序之后的数组</p>
</li>
<li>
<p>如果传进来的是汉字，则会按照字符串的Unicode(万国码)位点顺序排序</p>
</li>
<li>
<p>原数组发生变化</p>
</li>
</ul>
<pre><code class="language-JavaScript"> var ary=[1,3,10,50,2,120,30];
 ary.sort(function fn(a,b){
           return a-b;//这里是一个回调函数，把函数当作实参传给sort的方法
       })
       console.log(ary); //这里是升序，如果b-a则为降序
</code></pre>
<h3 id="10-arrayreverse倒序">10) Array.reverse()（倒序）</h3>
<ul>
<li>作用：使数组中元素倒序</li>
<li>参数：不需要参数</li>
<li>返回值：成员倒序的数组</li>
<li>原数组发生变化</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5]
	console.log(arr.reverse())    // [5,4,3,2,1]
  console.log(arr)    // [5,4,3,2,1]
</code></pre>
<h3 id="11-arrayconcat拼接数组">11) Array.concat()（拼接数组）</h3>
<ul>
<li>作用：拼接两个或多个数组</li>
<li>参数：
<ul>
<li>不传参数：数组的克隆</li>
<li>传参数：将传入的参数拼接到数组中、可以传多个</li>
</ul>
</li>
<li>返回值：拼接之后的新数组</li>
<li>原数组不发生变化</li>
</ul>
<pre><code class="language-JavaScript">let arr = [1,2,3,4,5]
	console.log(arr.concat([1,2]))  // [1,2,3,4,5,1,2]
  console.log(arr)   // [1,2,3,4,5]
</code></pre>
<h3 id="12-arrayjoin数组拼接成字符串">12) Array.join()（数组拼接成字符串）</h3>
<ul>
<li>作用：将数组的成员项通过制定字符拼接成字符串 参数：
<ul>
<li>不传参数：会默认按照逗号拼接</li>
<li>传参数：会按照参数字符拼接</li>
</ul>
</li>
<li>返回值：拼接之后的字符串</li>
<li>原数组不发生变化</li>
</ul>
<pre><code class="language-JavaScript">var arr = [1,2]
	var result = arr.join();
  console.log(result);//'1,2'
</code></pre>
<h3 id="13-arrayflat拉平数组">13) Array.flat()(拉平数组)</h3>
<ul>
<li>
<p>作用：用于将嵌套的数组“拉平”，变成一维数组</p>
</li>
<li>
<p>返回值：返回一个新数组;</p>
</li>
<li>
<p>参数：有参数，默认是一层，如果有多层，就需要传层数；如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
</li>
<li>
<p>原数组不改变</p>
</li>
<li>
<p>第一种</p>
</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,[1,2,3],6,78];
    let ary=arr.flat()
    console.log(ary);//[12,3,[1,2,3],6,78]
    console.log(arr)// [12, 3, 1, 2, 3, 6, 78]
</code></pre>
<ul>
<li>第二种</li>
</ul>
<pre><code class="language-JavaScript">    var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
consolelog(arr.flat(Infinity))//[1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
</code></pre>
<hr>
<h2 id="数组的遍历方法">数组的遍历方法</h2>
<h3 id="1-arraymap映射">1) Array.map()（映射）</h3>
<ul>
<li>
<p>作用：方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值；</p>
</li>
<li>
<p>参数：参数是一个回调函数；数组有几项，回调函数就执行多少次；在回调函数中处理数组中的每项；</p>
</li>
<li>
<p>返回值：映射的新数组；</p>
</li>
<li>
<p>原数组不发生变化；</p>
</li>
<li>
<p>示例：var ary = [1,2,3]; ary.map(function(item,index,arr){});</p>
<ul>
<li>item是遍历数组的每一项</li>
<li>index是遍历数组的索引</li>
<li>arr就是原数组</li>
</ul>
</li>
</ul>
<pre><code class="language-JavaScript">let ary = [1,2,3,4,5]
	ary.map( (item,index,arr)=&gt;{
	        item= item* 2
	        console.log(`item:${item}    index:${index}     arr:${arr}`)
	})   
	console.log(ary)
</code></pre>
<h3 id="2-arrayforeach遍历数组">2） Array.forEach()（遍历数组）</h3>
<ul>
<li>
<p>作用：遍历数组；</p>
</li>
<li>
<p>参数：参数是一个回调函数；数组有几项，回调函数就执行多少+ 次；</p>
</li>
<li>
<p>返回值：没有返回值；undefined；</p>
</li>
<li>
<p>原数组不发生变化；</p>
</li>
<li>
<p>示例：var ary = [1,2,3]; ary.forEach(function(item,index,arr){});</p>
<ul>
<li>item是遍历数组的每一项</li>
<li>index是遍历数组的索引</li>
<li>arr就是原数组</li>
</ul>
</li>
</ul>
<pre><code class="language-JavaScript">	let ary = [1,2,3,4,5]
	ary.forEach( (item,index,arr)=&gt;{
        console.log(`item:${item}    index:${index}     arr:${arr}`)
    })   
    //  item:1    index:0     arr:1,2,3,4,5
    //  item:2    index:1     arr:1,2,3,4,5
    //  item:3    index:2     arr:1,2,3,4,5
    //  item:4    index:3     arr:1,2,3,4,5
    //  item:5    index:4     arr:1,2,3,4,5

	let ary = [1,2,3,4,5]
	ary.forEach( (item,index,arr)=&gt;{
       item= item* 2
       console.log(`item:${item}    index:${index}     arr:${arr}`)
    })   
    console.log(ary)
    // item:2    index:0     arr:1,2,3,4,5
    // item:4    index:1     arr:1,2,3,4,5
    // item:6    index:2     arr:1,2,3,4,5
    // item:8    index:3     arr:1,2,3,4,5
    // item:10   index:4     arr:1,2,3,4,5
    // [1, 2, 3, 4, 5]
</code></pre>
<blockquote>
<p>ary.forEach()和ary.map()的区别<br>
1、 ary.forEach()是和for循环一样，是代替for。ary.map()是修改数组其中的数据，并返回新的数据。<br>
2、ary.forEach() 没有return  ary.map() 有return。<br>
3、map有映射，forEach没有映射。</p>
</blockquote>
<h3 id="3-arrayfindfindindex查找">3) Array.find&amp;findIndex(查找)</h3>
<ul>
<li>从左到右依次进行查找，找到符合条件的那一项，直接返回，不再进行查找；如果找不到，那么返回undefined； 返回true,说明就找到了；</li>
<li>find会根据回调函数的返回值，判断是否要继续向右查找；</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
	let  a =  arr.find((item,index)=&gt;{
        console.log(100);//输出三次
        return item&gt;20;
    })
    console.log(a);//45
</code></pre>
<blockquote>
<p>find() 方法基于ECMAScript 2015（ES6）规范，返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回undefined。</p>
</blockquote>
<blockquote>
<p>findIndex() 方法也基于ECMAScript 2015（ES6）规范，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。</p>
</blockquote>
<h3 id="4-arrayfilter过滤">4) Array.filter(过滤)</h3>
<ul>
<li>过滤;原数组不发生改变；返回一个过滤后的新数组</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
	let ary = arr.filter((item,index)=&gt;{
        // 根据当前函数的返回值是true来获取这一项；如果是false，返回值中就没有这一项；
        return item&gt;30;
    });
    console.log(arr);//[12, 3, 45, 6, 78]
    console.log(ary);//[45, 78]
</code></pre>
<h3 id="5-arrayevery测试所有元素">5) Array.every(测试所有元素)</h3>
<ul>
<li>每一个都是true则返回true，如果有一个是false，那么直接返回false；只要找到false，直接结束，不再继续向下查找；返回值是布尔值</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
		let e = arr.every((item,index)=&gt;{
        	return item&gt;13;
	    })
      console.log(e);//false
</code></pre>
<h3 id="6-arrayincludes包含">6) Array.includes()(包含)</h3>
<ul>
<li>作用：用来判断当前数组是否包含某个指定的值</li>
<li>参数：
<ul>
<li>有两个参数:第一个参数表示需要查找的元素，第二个表示从该索引位置开始查找</li>
<li>有一个参数：则自定义索引的参数缺省的情况下默认为0 ，从数组开始查找</li>
</ul>
</li>
<li>返回值：返回一个布尔值；如果有就返回true；，没有就返回false；</li>
<li>原数组不会发生变化</li>
</ul>
<pre><code class="language-JavaScript">let  arr = [12,3,45,6,78];
  console.log(arr.includes(45));//true
</code></pre>
<h3 id="7-arrayreduce累加器">7） Array.reduce(累加器)</h3>
<ul>
<li>作用：迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值</li>
<li>参数：接受两个参数：一个是对数组每个元素执行的回调方法，一个是初始值</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
	let  a = arr.reduce((prev,next)=&gt;{
        // prev : 第一次代表数组的第一项，以后都代表上一次回调函数的返回值；
        console.log(prev,next);//第一次输出：112 3，第二次输出：115 45，第三次输出：160 6，第四次输出：166 78
        return prev +next;
    });
    console.log(a);//244
</code></pre>
<ul>
<li>reduce回调函数后面可以传一个参数</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
	let  a = arr.reduce((prev,next)=&gt;{
        console.log(prev,next);//第一次输出：100 12，第二次输出：100 3，第三次输出：100 45，第四次输出：100 6，第五次输出：100 78
        return 100;
    },100);
    console.log(a);//100
</code></pre>
<h3 id="8-arraysome">8) Array.some()</h3>
<ul>
<li>返回一个布尔值；只要有一个符合条件就返回true；找到true，就不再向右进行查找；</li>
<li>some() 方法刚好同 every() 方法相反，some 测试数组元素时，只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false</li>
</ul>
<pre><code class="language-JavaScript">let arr = [12,3,45,6,78];
	let a  = arr.some((item,index)=&gt;{
        console.log(100);
        return item&gt;10;
    })
    console.log(a);//true
</code></pre>
<h3 id="9-arraykeys">9) Array.keys()</h3>
<ul>
<li>返回一个数组索引的迭代器</li>
</ul>
<pre><code class="language-JavaScript">var array = [&quot;abc&quot;, &quot;xyz&quot;];
var iterator = array.keys();
console.log(iterator.next()); // Object {value: 0, done: false}
console.log(iterator.next()); // Object {value: 1, done: false}
console.log(iterator.next()); // Object {value: undefined, done: false}
</code></pre>
<ul>
<li>我们可以利用Array.keys()轻松的创建一个从0开始的数组，上面我们说了new Array 和 Array 对单个数字的处理相同</li>
</ul>
<pre><code class="language-JavaScript">[...Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://lainbo.github.io/tag/vNG84wAEH">
            <span class="flex-auto">学习记录</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://lainbo.github.io/post/jiekoutest">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  可供日常使用的接口
                </h3>
              </a>
            </div>
          

          
        </div>

        

      </div>
    </div>

    <script src="https://lainbo.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
