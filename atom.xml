<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lainbo.github.io/</id>
    <title>Lainbo</title>
    <updated>2019-12-18T13:21:11.818Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lainbo.github.io/"/>
    <link rel="self" href="https://lainbo.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://lainbo.github.io//images/avatar.png</logo>
    <icon>https://lainbo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lainbo</rights>
    <entry>
        <title type="html"><![CDATA[流式布局]]></title>
        <id>https://lainbo.github.io//post/liu-shi-bu-ju</id>
        <link href="https://lainbo.github.io//post/liu-shi-bu-ju">
        </link>
        <updated>2019-11-29T11:58:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="移动web开发流式布局">移动web开发流式布局</h1>
<h3 id="10-移动端基础">1.0 移动端基础</h3>
<h4 id="11浏览器现状">1.1浏览器现状</h4>
<p>PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。</p>
<p>移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。</p>
<p>国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。</p>
<p><strong>总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。</strong></p>
<h4 id="12-手机屏幕的现状">1.2 手机屏幕的现状</h4>
<ul>
<li>移动端设备屏幕尺寸非常多，碎片化严重。</li>
<li>Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。</li>
<li>近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。</li>
<li>作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。</li>
</ul>
<h4 id="13常见移动端屏幕尺寸">1.3常见移动端屏幕尺寸</h4>
<img src="images/1.png">
<h4 id="14移动端调试方法">1.4移动端调试方法</h4>
<ul>
<li>Chrome DevTools（谷歌浏览器）的模拟手机调试</li>
<li>搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器</li>
<li>使用外网服务器，直接IP或域名访问</li>
</ul>
<h3 id="20-视口">2.0 视口</h3>
<p>视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口</p>
<h4 id="21-布局视口-layout-viewport">2.1 布局视口 layout viewport</h4>
<p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。</p>
<p>iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p>
<img src="./images/2.png">
<p>####2.2视觉视口 visual viewport</p>
<p>字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。</p>
<p>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。</p>
<img src="./images/3.png">
<h4 id="23理想视口-ideal-viewport">2.3理想视口 ideal viewport</h4>
<p>为了使网站在移动端有最理想的浏览和阅读宽度而设定</p>
<p>理想视口，对设备来讲，是最理想的视口尺寸</p>
<p>需要手动添写meta视口标签通知浏览器操作</p>
<p>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽</p>
<p><strong>总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口</strong></p>
<h4 id="24meta标签">2.4meta标签</h4>
<img src="./images/4.png">
<p>最标准的viewport设置</p>
<ul>
<li>视口宽度和设备保持一致</li>
<li>视口的默认缩放比例1.0</li>
<li>不允许用户自行缩放</li>
<li>最大允许的缩放比例1.0</li>
<li>最小允许的缩放比例1.0</li>
</ul>
<h3 id="30二倍图">3.0二倍图</h3>
<p>####3.1物理像素&amp;物理像素比</p>
<p>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是  750* 1334</p>
<p>我们开发时候的1px 不是一定等于1个物理像素的</p>
<p>一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比</p>
<p>如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放</p>
<p>lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p>
<p>对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊</p>
<p>在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题</p>
<p>通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题</p>
<h4 id="32背景缩放background-size">3.2背景缩放background-size</h4>
<p>background-size 属性规定背景图像的尺寸</p>
<pre><code>background-size: 背景图片宽度 背景图片高度;
</code></pre>
<p>单位： 长度|百分比|cover|contain;</p>
<p>cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</p>
<p>contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</p>
<h3 id="40-移动开发选择和技术解决方案">4.0 移动开发选择和技术解决方案</h3>
<p>####4.1移动端主流方案</p>
<p>1.单独制作移动端页面（主流）</p>
<p>通常情况下，网址域名前面加 m(mobile)<br>
可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。</p>
<p>也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站</p>
<p>京东pc端：</p>
<img src="./images/5.png">
<p>京东移动端：</p>
<img src="./images/6.jpg">
<p>2.响应式页面兼容移动端（其次）</p>
<img src="./images/7.jpg">
<p>响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配</p>
<h4 id="42-移动端技术解决方案">4.2 移动端技术解决方案</h4>
<p>1.移动端浏览器兼容问题</p>
<p>移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。</p>
<p>我们可以放心使用 H5 标签和 CSS3 样式。</p>
<p>同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可</p>
<p>2.移动端公共样式</p>
<p>移动端 CSS 初始化推荐使用 normalize.css/</p>
<p>Normalize.css：保护了有价值的默认值</p>
<p>Normalize.css：修复了浏览器的bug</p>
<p>Normalize.css：是模块化的</p>
<p>Normalize.css：拥有详细的文档</p>
<p>官网地址： <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p>
<h4 id="43-移动端大量使用-css3盒子模型box-sizin">4.3 移动端大量使用 CSS3盒子模型box-sizin</h4>
<p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</p>
<p>CSS3盒子模型：     盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</p>
<p>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</p>
<pre><code>/*CSS3盒子模型*/
box-sizing: border-box;
/*传统盒子模型*/
box-sizing: content-box;

</code></pre>
<p>移动端可以全部CSS3 盒子模型</p>
<p>PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</p>
<h4 id="44移动端特殊样式">4.4移动端特殊样式</h4>
<pre><code>    /*CSS3盒子模型*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮我们需要清除清除  设置为transparent 完成透明*/
    -webkit-tap-highlight-color: transparent;
    /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
    -webkit-appearance: none;
    /*禁用长按页面时的弹出菜单*/
    img,a { -webkit-touch-callout: none; }

</code></pre>
<h3 id="50移动端常见布局">5.0移动端常见布局</h3>
<p>移动端单独制作</p>
<ul>
<li>流式布局（百分比布局）</li>
<li>flex 弹性布局（强烈推荐）</li>
<li>less+rem+媒体查询布局</li>
<li>混合布局</li>
</ul>
<p>响应式</p>
<ul>
<li>媒体查询</li>
<li>bootstarp</li>
</ul>
<p>流式布局：</p>
<p>流式布局，就是百分比布局，也称非固定像素布局。</p>
<p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p>
<p>流式布局方式是移动web开发使用的比较常见的布局方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[请求、异步]]></title>
        <id>https://lainbo.github.io//post/qing-qiu-yi-bu</id>
        <link href="https://lainbo.github.io//post/qing-qiu-yi-bu">
        </link>
        <updated>2019-11-29T02:32:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="接口调用方式">接口调用方式</h3>
<ul>
<li>原生ajax</li>
<li>基于jQuery的ajax</li>
<li>fetch</li>
<li>axios</li>
</ul>
<h3 id="异步">异步</h3>
<ul>
<li>JavaScript的执行环境是「单线程」</li>
<li>所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程</li>
<li>异步模式可以一起执行<strong>多个任务</strong></li>
<li>JS中常见的异步调用
<ul>
<li>定时任何</li>
<li>ajax</li>
<li>事件函数</li>
</ul>
</li>
</ul>
<h3 id="promise">promise</h3>
<ul>
<li>主要解决异步深层嵌套的问题</li>
<li>promise 提供了简洁的API  使得异步操作更加容易</li>
</ul>
<pre><code class="language-html"> 
  &lt;script type=&quot;text/javascript&quot;&gt;
    /*
     1. Promise基本使用
           我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：		   resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数
    */


    var p = new Promise(function(resolve, reject){
      //2. 这里用于实现异步任务  setTimeout
      setTimeout(function(){
        var flag = false;
        if(flag) {
          //3. 正常情况
          resolve('hello');
        }else{
          //4. 异常情况
          reject('出错了');
        }
      }, 100);
    });
    //  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 
    //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了  
    p.then(function(data){
      console.log(data)
    },function(info){
      console.log(info)
    });
  &lt;/script&gt;
</code></pre>
<h3 id="基于promise发送ajax请求">基于Promise发送Ajax请求</h3>
<pre><code class="language-html"> 
  &lt;script type=&quot;text/javascript&quot;&gt;
    /*
      基于Promise发送Ajax请求
    */
    function queryData(url) {
     #   1.1 创建一个Promise实例
      var p = new Promise(function(resolve, reject){
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(){
          if(xhr.readyState != 4) return;
          if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
            # 1.2 处理正常的情况
            resolve(xhr.responseText);
          }else{
            # 1.3 处理异常情况
            reject('服务器错误');
          }
        };
        xhr.open('get', url);
        xhr.send(null);
      });
      return p;
    }
	# 注意：  这里需要开启一个服务 
    # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了
    queryData('http://localhost:3000/data')
      .then(function(data){
        console.log(data)
        #  1.4 想要继续链式编程下去 需要 return  
        return queryData('http://localhost:3000/data1');
      })
      .then(function(data){
        console.log(data);
        return queryData('http://localhost:3000/data2');
      })
      .then(function(data){
        console.log(data)
      });
  &lt;/script&gt;
</code></pre>
<h3 id="promise-基本api">Promise  基本API</h3>
<h4 id="实例方法">实例方法</h4>
<h5 id="then">.then()</h5>
<ul>
<li>得到异步任务正确的结果</li>
</ul>
<h5 id="catch">.catch()</h5>
<ul>
<li>获取异常信息</li>
</ul>
<h5 id="finally">.finally()</h5>
<ul>
<li>成功与否都会执行（不是正式标准）</li>
</ul>
<pre><code class="language-html">  
  &lt;script type=&quot;text/javascript&quot;&gt;
    /*
      Promise常用API-实例方法
    */
    // console.dir(Promise);
    function foo() {
      return new Promise(function(resolve, reject){
        setTimeout(function(){
          // resolve(123);
          reject('error');
        }, 100);
      })
    }
    // foo()
    //   .then(function(data){
    //     console.log(data)
    //   })
    //   .catch(function(data){
    //     console.log(data)
    //   })
    //   .finally(function(){
    //     console.log('finished')
    //   });

    // --------------------------
    // 两种写法是等效的
    foo()
      .then(function(data){
        # 得到异步任务正确的结果
        console.log(data)
      },function(data){
        # 获取异常信息
        console.log(data)
      })
      # 成功与否都会执行（不是正式标准） 
      .finally(function(){
        console.log('finished')
      });
  &lt;/script&gt;
</code></pre>
<h4 id="静态方法">静态方法</h4>
<h5 id="all">.all()</h5>
<ul>
<li><code>Promise.all</code>方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用<code>Promise.resolve</code>转换为一个promise)。它的状态由这三个promise实例决定</li>
</ul>
<h5 id="race">.race()</h5>
<ul>
<li><code>Promise.race</code>方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为<code>fulfilled</code>或<code>rejected</code>），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数</li>
</ul>
<p>​</p>
<pre><code class="language-html">  &lt;script type=&quot;text/javascript&quot;&gt;
    /*
      Promise常用API-对象方法
    */
    // console.dir(Promise)
    function queryData(url) {
      return new Promise(function(resolve, reject){
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(){
          if(xhr.readyState != 4) return;
          if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
            // 处理正常的情况
            resolve(xhr.responseText);
          }else{
            // 处理异常情况
            reject('服务器错误');
          }
        };
        xhr.open('get', url);
        xhr.send(null);
      });
    }

    var p1 = queryData('http://localhost:3000/a1');
    var p2 = queryData('http://localhost:3000/a2');
    var p3 = queryData('http://localhost:3000/a3');
     Promise.all([p1,p2,p3]).then(function(result){
       //   all 中的参数  [p1,p2,p3]   和 返回的结果一 一对应[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]
       console.log(result) //[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]
     })
    Promise.race([p1,p2,p3]).then(function(result){
      // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。
      console.log(result) // &quot;HELLO TOM&quot;
    })
  &lt;/script&gt;
</code></pre>
<h3 id="fetch">fetch</h3>
<ul>
<li>Fetch API是新的ajax解决方案 Fetch会返回Promise</li>
<li><strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</li>
<li>fetch(url, options).then(）</li>
</ul>
<pre><code class="language-html">  &lt;script type=&quot;text/javascript&quot;&gt;
    /*
      Fetch API 基本用法
      	fetch(url).then()
     	第一个参数请求的路径   Fetch会返回Promise   所以我们可以使用then 拿到请求成功的结果 
    */
    fetch('http://localhost:3000/fdata').then(function(data){
      // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据
      return data.text();
    }).then(function(data){
      //   在这个then里面我们能拿到最终的数据  
      console.log(data);
    })
  &lt;/script&gt;
</code></pre>
<h4 id="fetch-api-中的-http-请求">fetch API  中的 HTTP  请求</h4>
<ul>
<li>fetch(url, options).then(）</li>
<li>HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT
<ul>
<li>默认的是 GET 请求</li>
<li>需要在 options 对象中 指定对应的 method       method:请求使用的方法</li>
<li>post 和 普通 请求的时候 需要在options 中 设置  请求头 headers   和  body</li>
</ul>
</li>
</ul>
<pre><code class="language-html">   &lt;script type=&quot;text/javascript&quot;&gt;
        /*
              Fetch API 调用接口传递参数
        */
       #1.1 GET参数传递 - 传统URL  通过url  ？ 的形式传参 
        fetch('http://localhost:3000/books?id=123', {
            	# get 请求可以省略不写 默认的是GET 
                method: 'get'
            })
            .then(function(data) {
            	# 它返回一个Promise实例对象，用于获取后台返回的数据
                return data.text();
            }).then(function(data) {
            	# 在这个then里面我们能拿到最终的数据  
                console.log(data)
            });

      #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关   
        fetch('http://localhost:3000/books/456', {
            	# get 请求可以省略不写 默认的是GET 
                method: 'get'
            })
            .then(function(data) {
                return data.text();
            }).then(function(data) {
                console.log(data)
            });

       #2.1  DELETE请求方式参数传递      删除id  是  id=789
        fetch('http://localhost:3000/books/789', {
                method: 'delete'
            })
            .then(function(data) {
                return data.text();
            }).then(function(data) {
                console.log(data)
            });

       #3 POST请求传参
        fetch('http://localhost:3000/books', {
                method: 'post',
            	# 3.1  传递数据 
                body: 'uname=lisi&amp;pwd=123',
            	#  3.2  设置请求头 
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            })
            .then(function(data) {
                return data.text();
            }).then(function(data) {
                console.log(data)
            });

       # POST请求传参
        fetch('http://localhost:3000/books', {
                method: 'post',
                body: JSON.stringify({
                    uname: '张三',
                    pwd: '456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(function(data) {
                return data.text();
            }).then(function(data) {
                console.log(data)
            });

        # PUT请求传参     修改id 是 123 的 
        fetch('http://localhost:3000/books/123', {
                method: 'put',
                body: JSON.stringify({
                    uname: '张三',
                    pwd: '789'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(function(data) {
                return data.text();
            }).then(function(data) {
                console.log(data)
            });
    &lt;/script&gt;
</code></pre>
<h4 id="fetchapi-中-响应格式">fetchAPI 中 响应格式</h4>
<ul>
<li>用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如<code>JSON</code>，<code>BLOB</code>或者<code>TEXT</code>等等</li>
</ul>
<pre><code class="language-js">
    /*
      Fetch响应结果的数据格式
    */
    fetch('http://localhost:3000/json').then(function(data){
      // return data.json();   //  将获取到的数据使用 json 转换对象
      return data.text(); //  //  将获取到的数据 转换成字符串 
    }).then(function(data){
      // console.log(data.uname)
      // console.log(typeof data)
      var obj = JSON.parse(data);
      console.log(obj.uname,obj.age,obj.gender)
    })

</code></pre>
<h3 id="axios">axios</h3>
<ul>
<li>基于promise用于浏览器和node.js的http客户端</li>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
<li>能转换请求和响应数据</li>
</ul>
<h4 id="axios基础用法">axios基础用法</h4>
<ul>
<li>get和 delete请求传递参数
<ul>
<li>通过传统的url  以 ? 的形式传递参数</li>
<li>restful 形式传递参数</li>
<li>通过params  形式传递参数</li>
</ul>
</li>
<li>post  和 put  请求传递参数
<ul>
<li>通过选项传递参数</li>
<li>通过 URLSearchParams  传递参数</li>
</ul>
</li>
</ul>
<pre><code class="language-js">    # 1. 发送get 请求 
	axios.get('http://localhost:3000/adata').then(function(ret){ 
      #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面
      // 注意data属性是固定的用法，用于获取后台的实际数据
      // console.log(ret.data)
      console.log(ret)
    })
	# 2.  get 请求传递参数
    # 2.1  通过传统的url  以 ? 的形式传递参数
	axios.get('http://localhost:3000/axios?id=123').then(function(ret){
      console.log(ret.data)
    })
    # 2.2  restful 形式传递参数 
    axios.get('http://localhost:3000/axios/123').then(function(ret){
      console.log(ret.data)
    })
	# 2.3  通过params  形式传递参数 
    axios.get('http://localhost:3000/axios', {
      params: {
        id: 789
      }
    }).then(function(ret){
      console.log(ret.data)
    })
	#3 axios delete 请求传参     传参的形式和 get 请求一样
    axios.delete('http://localhost:3000/axios', {
      params: {
        id: 111
      }
    }).then(function(ret){
      console.log(ret.data)
    })

	# 4  axios 的 post 请求
    # 4.1  通过选项传递参数
    axios.post('http://localhost:3000/axios', {
      uname: 'lisi',
      pwd: 123
    }).then(function(ret){
      console.log(ret.data)
    })
	# 4.2  通过 URLSearchParams  传递参数 
    var params = new URLSearchParams();
    params.append('uname', 'zhangsan');
    params.append('pwd', '111');
    axios.post('http://localhost:3000/axios', params).then(function(ret){
      console.log(ret.data)
    })

 	#5  axios put 请求传参   和 post 请求一样 
    axios.put('http://localhost:3000/axios/123', {
      uname: 'lisi',
      pwd: 123
    }).then(function(ret){
      console.log(ret.data)
    })

</code></pre>
<h4 id="axios-全局配置">axios 全局配置</h4>
<pre><code class="language-js">#  配置公共的请求头 
axios.defaults.baseURL = 'https://api.example.com';
#  配置 超时时间
axios.defaults.timeout = 2500;
#  配置公共的请求头
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
# 配置公共的 post 的 Content-Type
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';


</code></pre>
<h4 id="axios-拦截器">axios 拦截器</h4>
<ul>
<li>请求拦截器
<ul>
<li>请求拦截器的作用是在请求发送前进行一些操作
<ul>
<li>例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易</li>
</ul>
</li>
</ul>
</li>
<li>响应拦截器
<ul>
<li>响应拦截器的作用是在接收到响应后进行一些操作
<ul>
<li>例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">	# 1. 请求拦截器 
	axios.interceptors.request.use(function(config) {
      console.log(config.url)
      # 1.1  任何请求都会经过这一步   在发送请求之前做些什么   
      config.headers.mytoken = 'nihao';
      # 1.2  这里一定要return   否则配置不成功  
      return config;
    }, function(err){
       #1.3 对请求错误做点什么    
      console.log(err)
    })
	#2. 响应拦截器 
    axios.interceptors.response.use(function(res) {
      #2.1  在接收响应做些什么  
      var data = res.data;
      return data;
    }, function(err){
      #2.2 对响应错误做点什么  
      console.log(err)
    })
</code></pre>
<h3 id="async-和-await">async  和 await</h3>
<ul>
<li>async作为一个关键字放到函数前面
<ul>
<li>任何一个<code>async</code>函数都会隐式返回一个<code>promise</code></li>
</ul>
</li>
<li><code>await</code>关键字只能在使用<code>async</code>定义的函数中使用
<ul>
<li>​    await后面可以直接跟一个 Promise实例对象</li>
<li>​     await函数不能单独使用</li>
</ul>
</li>
<li><strong>async/await 让异步代码看起来、表现起来更像同步代码</strong></li>
</ul>
<pre><code class="language-js"> 	# 1.  async 基础用法
    # 1.1 async作为一个关键字放到函数前面
	async function queryData() {
      # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象
      var ret = await new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('nihao')
        },1000);
      })
      // console.log(ret.data)
      return ret;
    }
	# 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程
    queryData().then(function(data){
      console.log(data)
    })

	#2.  async    函数处理多个异步函数
    axios.defaults.baseURL = 'http://localhost:3000';

    async function queryData() {
      # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码   
      
      var info = await axios.get('async1');
      #2.2  让异步代码看起来、表现起来更像同步代码
      var ret = await axios.get('async2?info=' + info.data);
      return ret.data;
    }

    queryData().then(function(data){
      console.log(data)
    })
</code></pre>
<h3 id="图书列表案例">图书列表案例</h3>
<h4 id="1-基于接口案例-获取图书列表">1. 基于接口案例-获取图书列表</h4>
<ul>
<li>导入axios   用来发送ajax</li>
<li>把获取到的数据渲染到页面上</li>
</ul>
<pre><code class="language-html">  &lt;div id=&quot;app&quot;&gt;
        &lt;div class=&quot;grid&quot;&gt;
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;编号&lt;/th&gt;
                        &lt;th&gt;名称&lt;/th&gt;
                        &lt;th&gt;时间&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    &lt;!-- 5.  把books  中的数据渲染到页面上   --&gt;
                    &lt;tr :key='item.id' v-for='item in books'&gt;
                        &lt;td&gt;{{item.id}}&lt;/td&gt;
                        &lt;td&gt;{{item.name}}&lt;/td&gt;
                        &lt;td&gt;{{item.date }}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt;
                            &lt;span&gt;|&lt;/span&gt;
                            &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
	1.  导入axios   
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        /*
             图书管理-添加图书
         */
        # 2   配置公共的url地址  简化后面的调用方式
        axios.defaults.baseURL = 'http://localhost:3000/';
        axios.interceptors.response.use(function(res) {
            return res.data;
        }, function(error) {
            console.log(error)
        });

        var vm = new Vue({
            el: '#app',
            data: {
                flag: false,
                submitFlag: false,
                id: '',
                name: '',
                books: []
            },
            methods: {
                # 3 定义一个方法 用来发送 ajax 
                # 3.1  使用 async  来 让异步的代码  以同步的形式书写 
                queryData: async function() {
                    // 调用后台接口获取图书列表数据
                    // var ret = await axios.get('books');
                    // this.books = ret.data;
					# 3.2  发送ajax请求  把拿到的数据放在books 里面   
                    this.books = await axios.get('books');
                }
            },

            mounted: function() {
				#  4 mounted  里面 DOM已经加载完毕  在这里调用函数  
                this.queryData();
            }
        });
    &lt;/script&gt;
</code></pre>
<h4 id="2-添加图书">2   添加图书</h4>
<ul>
<li>获取用户输入的数据   发送到后台</li>
<li>渲染最新的数据到页面上</li>
</ul>
<pre><code class="language-js"> methods: {
    handle: async function(){
          if(this.flag) {
            // 编辑图书
            // 就是根据当前的ID去更新数组中对应的数据
            this.books.some((item) =&gt; {
              if(item.id == this.id) {
                item.name = this.name;
                // 完成更新操作之后，需要终止循环
                return true;
              }
            });
            this.flag = false;
          }else{
            # 1.1  在前面封装好的 handle 方法中  发送ajax请求  
            # 1.2  使用async  和 await 简化操作 需要在 function 前面添加 async   
            var ret = await axios.post('books', {
              name: this.name
            })
            # 1.3  根据后台返回的状态码判断是否加载数据 
            if(ret.status == 200) {
             # 1.4  调用 queryData 这个方法  渲染最新的数据 
              this.queryData();
            }
          }
          // 清空表单
          this.id = '';
          this.name = '';
        },        
 }         
</code></pre>
<h4 id="3-验证图书名称是否存在">3  验证图书名称是否存在</h4>
<ul>
<li>添加图书之前发送请求验证图示是否已经存在</li>
<li>如果不存在 往后台里面添加图书名称
<ul>
<li>图书存在与否只需要修改submitFlag的值即可</li>
</ul>
</li>
</ul>
<pre><code class="language-js"> watch: {
        name: async function(val) {
          // 验证图书名称是否已经存在
          // var flag = this.books.some(function(item){
          //   return item.name == val;
          // });
          var ret = await axios.get('/books/book/' + this.name);
          if(ret.status == 1) {
            // 图书名称存在
            this.submitFlag = true;
          }else{
            // 图书名称不存在
            this.submitFlag = false;
          }
        }
},
</code></pre>
<h4 id="4-编辑图书">4.  编辑图书</h4>
<ul>
<li>根据当前书的id 查询需要编辑的书籍</li>
<li>需要根据状态位判断是添加还是编辑</li>
</ul>
<pre><code class="language-js"> methods: {
        handle: async function(){
          if(this.flag) {
            #4.3 编辑图书   把用户输入的信息提交到后台
            var ret = await axios.put('books/' + this.id, {
              name: this.name
            });
            if(ret.status == 200){
              #4.4  完成添加后 重新加载列表数据
              this.queryData();
            }
            this.flag = false;
          }else{
            // 添加图书
            var ret = await axios.post('books', {
              name: this.name
            })
            if(ret.status == 200) {
              // 重新加载列表数据
              this.queryData();
            }
          }
          // 清空表单
          this.id = '';
          this.name = '';
        },
        toEdit: async function(id){
          #4.1  flag状态位用于区分编辑和添加操作
          this.flag = true;
          #4.2  根据id查询出对应的图书信息  页面中可以加载出来最新的信息
          # 调用接口发送ajax 请求  
          var ret = await axios.get('books/' + id);
          this.id = ret.id;
          this.name = ret.name;
        },
</code></pre>
<h4 id="5-删除图书">5 删除图书</h4>
<ul>
<li>把需要删除的id书籍 通过参数的形式传递到后台</li>
</ul>
<pre><code class="language-js">   deleteBook: async function(id){
          // 删除图书
          var ret = await axios.delete('books/' + id);
          if(ret.status == 200) {
            // 重新加载列表数据
            this.queryData();
          }
   }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://lainbo.github.io//post/hello-gridea</id>
        <link href="https://lainbo.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你11111可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>